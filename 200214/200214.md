# 200214

---

# 웹 프로그래밍의 이해

> 간단한 내용을 웹 페이지에 표시할 때는 HTML 태그만으로도 충분하지만
> 데이터가 실시간으로 변화하는 것을 처리하거나 저장하기에는 불충분함
>
> 이렇게 동적으로 변화하는 데이터를 처리하고 표시하기 위해
> 웹 프로그래밍 언어가 개발됨

- CGI, ASP, PHP, JSP 등이 웹 프로그래밍 언어에 포함됨
  우리가 공부할 것은 JSP
- 웹 프로그래밍은 기본적으로 클라이언트(Client) / 서버(Server) 방식으로 이루어짐
- 클라이언트가 특정 페이지를 웹 서버에 요청하면
  웹 서버가 이를 처리한 후 결과를 다시 클라이언트에게 응답하는 구조

## 웹 애플리케이션의 구조 및 구성 요소

> 웹 애플리케이션이란 웹을 기반으로 실행되는 프로그램을 의미하며
> 웹 프로그래밍을 통해 구현함

### 웹 애플리케이션 처리 과정

1. 웹 브라우저가 웹 서버에 특정 페이지 요청
2. 웹 서버가 웹 브라우저의 요청을 받아서 요청된 페이지의 로직 및
   데이터베이스와의 연동을 위해 웹 애플리케이션 서버에 이들의 처리를 요청
3. 웹 애플리케이션 서버는 데이터베이스와의 연동이 필요한 경우 이를 수행
4. 로직 및 데이터베이스 작업의 처리 결과를 웹 서버에 전송
5. 웹 서버가 웹 브라우저에 결과 응답

### 웹 애플리케이션 구성 요소 및 기능

| 구성 요소                 | 기능                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 웹 브라우저               | 웹에서 클라이언트이며 사용자의 작업창이라고도 함<br />ex) IE, Chrome, Safari, FireFox etc. |
| 웹 서버                   | 웹 브라우저의 요청을 받아들이며 작업의 결과를 웹 브라우저에 응답하기도 하는 곳<br />요청된 페이지의 로직 및 DB와의 연동을 위해 애플리케이션 서버에 이들의 처리를 요청하는 작업을 수행<br />ex) Apache(아파치), IIS(Internet Information Server) |
| 웹 애플리케이션 서버(WAS) | 요청된 페이지의 로직 및 DB와의 연동을 처리하는 부분<br />영어권에서는 그냥 애플리케이션 서버라고 함<br />ex) WebLogic, WebSphere, Apache Tomcat |
| 데이터베이스(DB)          | 데이터 저장소로 웹에서 발생한 모든 데이터가 저장되는 영역<br />게시판의 글이나 회원 정보 등이 저장됨<br />ex) Oracle, MySQL |

*※ Apache Tomcat: Jakarta Project에서 무료로 제공하는 웹 컨테이너
웹 애플리케이션 서버 기능을 갖고 있지만
JSP와 서블릿을 서비스해주는 웹 컨테이너로 주로 사용되기 때문에
보통 웹 컨테이너로 불림*

## 웹 애플리케이션 처리 방식

> CGI 방식과 웹 애플리케이션 서버(WAS) 방식이 있음
> 기본적인 처리 구조는 같으나
> 웹 서버가 웹 애플리케이션 프로그램을 사용하는 방식에 차이가 있음

### CGI 방식

> Common Gateway Interface

- 웹 서버가 웹 애플리케이션을 직접 호출하는 구조
- 1개의 요청에 대해 1개의 프로세스가 생성되어 요청을 처리한 뒤 종료됨
  즉 1000명의 사용자가 요청하면 1000개의 프로세스 생성
- 동시 접속자가 많은 경우 시스템에 과부하를 초래
- 현재 일부의 UNIX 플랫폼을 제외하고는 CGI 방식을 사용하지 않음

※ 프로세스(Process): 메모리 할당을 받은 프로그램 즉,실행 중인 프로그램을 의미

### WAS 방식

> Web Application Server

- 웹 서버가 애플리케이션 프로그램을 직접 처리하지 않고,
  웹 애플리케이션 서버가 처리하도록 넘기는 방식
- 여러 명의 사용자가 동일한 페이지를 요청할 때 오직 한 개의 프로세스만 할당
  사용자의 요청을 쓰레드(Thread) 방식으로 처리함
- 프로세스가 하나만 생성되기 때문에 메모리 절약 가능
- CGI 방식에 비해 더 많은 사용자에게 서비스를 제공할 수 있으며
  전체적으로 성능도 향상되어 보다 안정적인 웹 서비스 제공 가능
- JSP 역시 WAS 방식을 취함

## 웹 앱 구현 방식

> 실행 코드 방식과 스크립트 코드 방식이 있음

### 실행 코드 방식

- 미리 컴파일된 실행 츠로그램을 사용자 요청에 따라 실행
- CGI 방식

### 스크립트 코드 방식

- Client Side Script: 클라이언트 쪽에서 처리하는 스크립트 언어
  ex) JavaScript, VBScript etc.
- Server Side Script: 서버 쪽에서 처리하는 스크립트 언어
  ex) JSP, ASP, PHP etc.
- 사용자의 요청이 발생하면 스크립트 코드를 번역하여 번역된 코드를 실행
- 스크립트 코드는 최초 요청이 있을 때 단 한번만 번역되며
  이후에는 번역된 코드가 실행됨
  → 실행 코드 방식과 처리 속도에 큰 차이 없음
- 실행 코드 방식에 비해 쉽고 빠르게 웹 앱 구현 가능
- WAS 방식으로 실행 코드 방식에 비해 전체적인 성능이 뛰어남

---

# Servlet

> Server + Applet
> Java 언어를 기반으로 하는 동적 웹 페이지를 작성할 수 있도록 지원

## Servlet 개요

- 멀티 쓰레딩(Multi Thread)을 통해 사용자 요구를 처리하고 가공해서
  이에 대한 결과를 사용자에게 응답함
- 자바 프로그램과 작성하는 형식이 거의 같기 때문에
  자바를 학습하지 않으면 작성하기 어려움
- 자바 코드 안에 HTML 태그가 혼재되어 있어
  작업이 분리되지 않기 때문에 업무 효율성이 떨어짐
- 서블릿은 사용자용 뷰와 프로그램 로직 사이를 제어하는 컨트롤러(Controller)로 주로 사용
- JSP와 서블릿은 상호 연계되어 사용됨

## HTTP 프로토콜

> 연결을 유지하지 않고(Connectionless, 비연결성),
> 서버의 상태에 상관하지 않는(Stateless, 비상태성) 특징을 가짐

- 웹 브라우저는 HTTP 프로토콜에 맞게 요청(request)을 웹 서버에 전송
- 웹 서버는 HTTP 프로토콜에 맞게 요청에 따른 응답(reply)을 웹 브라우저에 전송

### HTTP Method

| 메소드  | 특징                                                         |
| ------- | ------------------------------------------------------------ |
| Get     | http header에 정보를 실어 보냄<br />메소드 생략 시 기본값<br />url 뒤에 요청 쿼리가 붙음<br />전달 속도 빠름<br />256byte가 한계<br />적은 양의 데이터 전송시 유리 |
| Post    | http body에 정보를 실어 보냄<br />데이터 크기에 제한이 없음<br />보안에 유리 |
| Head    | Header(서버)의 정보만 얻어낼 때 사용                         |
| Put     | Resource를 저장할 때 사용                                    |
| Delete  | Resource를 제거할 때 사용                                    |
| Trace   | 클라이언트에서 서버까지 가는 경로 추적                       |
| Options | 서버 성능 등을 확인할 때 사용                                |

*※ Put과 Delete를 허용하면 서버의 안정성이 떨어짐*

## 서블릿 동작 원리

- javax.servlet이나 javax.servlet.http 패키지의 클래스와 인터페이스를 사용해 서블릿 생성
- main() 메소드를 갖지 않는 대신 서블릿의 service() 메소드를 서버가 호출함

### Generic 서블릿

- javax.servlet 패키지는 프로토콜에 독립적인 서블릿을 만들기 위한 클래스 제공
- 서블릿은 GenericServlet 클래스를 상속받아 작성
- service() 메소드를 재정의해야 함
- service() 메소드는 클라이언트의 요청을 처리하는 request 객체와 
  요청 처리 결과를 반환하는 response 객체를 매개 변수로 가짐
- ServletRequest, ServletResponse 클래스에서
  제너릭 서블릿의 request와 response에 대한 접근 제공

### HTTP 서블릿

- javax.servlet.http 패키지는 HTTP 프로콜의 고유한 기능(Get, Post 등)을 제공하는 서블릿을 만드는 클래스 제공
- 서블릿은 HttpServlet 클래스를 상속받아 작성
- service() 메소드 대신 GET 요청을 다루기 위한 doGet() 메소드와
  POST 요청을 다루기 위한 doPost() 메소드를 재정의
- HttpServletRequest, HttpServletResponse 클래스에서 요청과 응답에 대한 기능 제공

### HTTP 서블릿 요청/응답 과정

1. 클라이언트의 서비스 요청
2. 컨테이너에서 객체 생성 유무 체크(only one)
3. 객체가 있는 경우는 생성하지 않고
   객체가 없는 경우 객체 생성(메모리에 올림)
4. Invoker 실행
   작업용 request당 하나씩 thread를 만듦
5. thread에서 service() 메소드(response 내용 포함) 호출
   클라이언트당 1개씩 생성
6. 결과를 클라이언트에 보내며 이때 결과를 mime type으로 보냄
   웹 브라우저의 mime type은 text/html

※ service() 메소드가 호출될 때마다 doGet() 메소드가 자동 호출됨

---

# JSP

> Java Server Pages
> 자바를 기반으로 하며 서블릿보다는 자바 코드에 덜 의존적인 웹 프로그래밍 언어

## JSP 개요

- 서블릿과 동일한 처리 구조를 가짐
- 서블릿 기술을 확장한 것이며
  웹 상에서 100% 순수 자바만으로 서버 사이드 모듈을 개발하기 위한 기술
- 페이지의 요청이 발생하면 최초 한 번만 자바 코드로 변환된 후 서블릿 클래스로 컴파일 됨
  즉, JSP는 실행시 서블릿으로 변환됨
- 코드를 수정하지 전까지는 재변환 작업이 일어나지 않기 때문에
  수행 속도에서 서블릿과 큰 차이는 없음
- JSP는 주로 사용자용 화면인 뷰(View)의 구현에 사용
- 서블릿과 마찬가지로 서버 사이드에서 DB와 연동하여 화면에 데이터 표시 가능
- JSP 웹 프로그래밍을 위해서는 웹 서버, 웹 애플리케이션 서버, 웹 컨테이너 필요

## JSP 특징

> Java를 기반으로 만들어졌기 때문에 자바 언어의 특징을 그대로 가짐

- 객체 지향적
- 플랫폼에 독립적
- 네트워크 지향적
- 높은 보안성
- 멀티 쓰레드 지원
- 코드가 친근함

※ 자바는 J2SE(Standard Edition), J2EE(Enterprise Edition),
J2ME(Micro Edition)로 나누어져 개발되는데 JSP는 J2EE를 구성하는 기술 중 하나임

## J2EE 구성
> 컨테이너(container)가 관리하는 컴포넌트 그룹(container-managed component)과
> 서비스 API(service API)그룹으로 나누어짐﻿

### Container

- 여러 가지 컴포넌트를 가지며
   컴포넌트들이 제공하는 각종 서비스를 관리하는 런타임 환경 제공
- 프로그래밍에서 가장 중요한 요소는 재사용 가능한 비즈니스 로직을
  작성할 수 있게 도와주는 컴포넌트
- 웹 컨테이너는 서블릿과 JSP에 대한 실행 환경 제공
- EJB 컨테이너는 Enterprise JavaBean에 대한 실행 환경 제공

#### Container 구성 기술

1. Servlet: 서버 쪽에서 실행되는 프로그램
2. JSP: 컴포넌트를 웹 페이지에 내장시켜 통합시킬 수 있음
   HTML, Java, JavaBean 컴포넌트 등을 하나의 웹 페이지 내에 포함
3. EJB(Enterprise Java Beans): 비즈니스 로직을 구현한 각종 컴포넌트들을
   서버에 분산시켜 놓고, 지속성 있는 데이터를 객체 지향적으로 표현 가능

### Service API

- 실제로 사용하는 각종 서비스 환경 제공
- JDBC: J2EE 구성요소로, DataSource나 분산 트랜잭션 지원과 같은 향상된 기능 제공
- XML(eXtensible Markup Language): J2EE에서 디플로이먼트 디스크립터(deployment descriptors)를 작성하는 포맷, 디플로이먼트 디스크립터는 J2EE 앱 환경 설정시 사용
- JNDI(Java Naming and Directory Interface): 기업형 네이밍과 디렉토리 서비스에 접근할 수 있게 하는 API, 분산 환경에 있는 서버들 간에 객체 공유 방법 제공

---

# JSP 환경설정

## JAVA JDK 설치

> 이미 다룬 내용이므로 생략

## 서버 설치_APACHE TOMCAT

1. http://tomcat.apache.org/ 접속

2. TOMCAT 8.5.51 버전 설치
   최신 버전은 버그가 있을 가능성이 높기 때문에 최신 버전의 이전 버전 사용

3. 실행 파일로 설치
   [32-bit/64-bit Windows Service Installer](http://apache.mirror.cdnetworks.com/tomcat/tomcat-8/v8.5.51/bin/apache-tomcat-8.5.51.exe) ([pgp](https://www.apache.org/dist/tomcat/tomcat-8/v8.5.51/bin/apache-tomcat-8.5.51.exe.asc), [sha512](https://www.apache.org/dist/tomcat/tomcat-8/v8.5.51/bin/apache-tomcat-8.5.51.exe.sha512))
   zip 파일로 설치하면 환경 설정을 따로 또 해야 함

4. **Choose Components**
   예제가 필요한 경우 Examples(예제) 체크

5. **Configuration**
HTTP/ 1.1 Connector Port를 사용하지 않는 포트로 지정 ex) 8090
   (오라클 서버가 기본적으로 8080포트를 사용하기 때문에 변경이 필요함)
   User Name: admin, Password : 1234
   
6. **Java Virtual Machine**
   JRE 설치 경로 확인(톰캣 서버와 자바가 연결되기 때문에 필요)
   Java가 설치되지 않았다면 경로가 표시되지 않으므로 확인 필요

7. **Choose Install Location**
   편의를 위해 C:\Tomcat 8.5 로 수정

8. **Install**

9. **Run Apache Tomcat** 해제
   서버가 당장 필요하지 않기 때문에 체크박스 해제

10. **Finish**

## TOMCAT 실행

### Tomcat8w

1. C:\Tomcat 8.5\bin 폴더로 이동
2. Tomcat8w 실행
   윈도우용 서버 실행 프로그램
3. General 탬에서 Start로 서버 실행
   Stop으로 서버 중지

*※ 실행은 편리하지만 상태 관리를 하기 불편함*

### Tomcat8

> 권장되는 서버 실행 파일

1. 동일한 경로의 Tomcat8 실행
2. 켜져 있는 상태에서 Tomcat8을 하나 더 실행하면 에러 발생
   한 번 더 실행하면 바로 에러가 발생하기 때문에 서버가 가동중인지 확인하기가 편리함

## Eclipse 설정

> 설치는 이미 다루었기 때문에 생략

1. workspace 변경
   File → Switch Workspace → Other..
   JSP 작업을 원하는 디렉토리 지정
2. **Create a Dynamic Web project**
3. **Target runtime** 
   New Runtime... → Tomcat 버전과 맞는 Apache Tomcat v8.5 선택
   **Create a new local server 체크**
   서버 연결
4. **Tomcat installation directory**
   톰캣 서버 설치 경로 설정 C:\Tomcat 8.5
   **JRE_서블릿 사용을 위해 필요**
   jdk or jre 버전 선택
5. **Finish**
6. **Web Module**이 나올 때까지 Next
   Generate web.xml deployment descriptor 체크
7. **Finish**

※ Context root: 프로젝트 폴더

※ Content directory: WebContent
작업영역으로 html, css, js, jsp 파일이 저장되는 영역

### Eclipse Tomcat 서버 에러

> 별다른 작업 없이 서버를 실행했을 때 에러가 발생하는 경우

- 콘솔창이 있는 아래쪽 바의 Servers 탭 클릭
- Tomcat v 8.5 Server ~ 더블 클릭
- Overview 창의 오른쪽으로 보면 Ports 탭이 있음
- Tomcat admin port 와 HTTP/1.1의 포트 번호를 다르게 설정하면 해결됨
  ex) 톰캣 포트 번호: 8090, HTTP/1.1 포트 번호: 8091, admin port: 8092
- 포트번호는 다르지만 HTTP/1.1과 admin port의 process id는 동일함

*※ 포트는 충돌하는 경우가 많기 때문에 여러가지 에러 케이스를 살펴보는 것을 추천*

### Window CMD 네트워크 확인 및 포트 종료

#### 특정 포트 번호 확인

- 명령어 netstat
- -a: 모든 연결 / 수신 대기 포트 표시
- -n: 주소와 포트 번호를 숫자 형식으로 표시
- -o: 각 연결의 소유자 프로세스 ID 표시
- findstr: 해당 문자열에 해당하는 값을 찾아주는 명령어

```powershell
netstat -ano | findstr 포트번호
```

#### 포트 종료

- 명령어 taskkill
- /f : 프로세스 강제 종료
- /pid: 종료할 프로세스 PID 지정

```powershell
taskkill /f /pid 프로세스 아이디
```

※ 종료는 포트 번호가 아니라 프로세스 아이디를 통해서 하기 때문에
포트 번호 확인시 해당 포트를 사용 중인 프로세스 아이디를 확인해야함

### Eclipse 한글 설정

1. Window 메뉴
2. Preferences
3. **Web**
   CSS Files, HTML Files, JSP Files
   각각의 Encoding을 UTF-8로 설정
4. Preferences - General - **Workspace**
   Text file encoding → Other 선택 → UTF-8 설정
5. JSP 파일의 pageEncoding, charset 역시 UTF-8로 설정

### Dynamic Web Project 구조

- Dynamic Web Project
  - Java Resources
    - src: 자바(서블릿) 파일이 저장되는 폴더
      빈즈파일(웹에서 사용하는 자바 파일)이 저장된 영역
  - WebContent: 메인 페이지 저장 폴더
    ex) index.html, index.jsp or main.jsp
    - images: 이미지 파일 저장
    - js: JavaScript 파일을 저장하는 폴더
    - views: html 페이지 폴더들을 모아두는 폴더
  - META-INF: DB연동시 사용하는 XML파일 저장 폴더
  - WEB-INF
    - lib: 자바 외부 라이브러리 파일이 저장되는 위치
      ex) ojdbc6.jar
      - web.xml 웹프로그래밍에서 사용할 환경설정 파일

---

# 자바 시험 준비

1. 20p 자바의 특징
   플랫폼에 독립적 but 사용은 의존적
2. 기본자료형
   **byte** : 입출력 기본 자료형
   int : 연산 기본 단위
   long: 마지막에 L or l
   flost: f or F
   double: 실수 기본 단위
3. char 인코딩
   유니코드
   ASCII
4. 형 변환
   묵시(작은 -> 큰) / 명시(큰 -> 작은)
5. 연산자
   관계, 논리, 연산(증감이 특히 중요)
6. 삼항연산자 (식 )?  참일 때 : 거짓일 때
7. 제어문
   if, if else, if esle-if, 다중 if, switch ~ case ~
8. 반복문
   for(반복 횟수 O), while(반복 횟수 X), do ~ while
9. Class, Instance
   추상화- 기존에 존재하지 않는 새로운 자료형 저장
   캡슐화- 정확한 값만 저장되도록 함
   상속- 기존에 존재하는 클래스의 기능을 확장하면서 새로 생성하는 것
   다형성
10. 멤버 변수
    데이터 저장 목적으로 사용
    클래스 내 모든 메소드에서 사용 가능
11. 지역 변수
    메소드 내부에서만 사용 가능
12. 메소드_매개변수/ 반환값 종류
    O,O / O, X / X, X
13. 메소드_객체 생성 유무에 따라 분류
    일반 메소드 / 정적 메소드
14. 인스턴스 = 객체
    인스턴스는 실제로 메모리에 잡힌 경우에 사용
    객체는 개념적인 뜻
15. main()
    프로그램 실행을 책임지는 메소드
16. 생성자
    멤버 변수 초기화 목적
17. 오버로딩
    메소드의 이름은 갖지만 **매개변수를 다르게** 해서
    같은 이름으로 다른 기능을 하는 메소드 작성
18. 캡슐화
    데이터 은닉/ 보호
    setter, getter가 필요한 이유
19. this-현재 객체, super-상위 객체
20. 객체간 협력
    클래스간 연결 has-a, is-a(상속)
21. static
    공유 목적으로 사용할 변수, 메소드에 작성
    정적 메소드(변수) = 클래스 메소드(변수)
    일반 메소드(변수) = 인스턴스 메소드(변수)
22. Singleton
23. 배열
    1차, 2차 배열, 사용 목적
    객체 배열(각 객체의 주소값 저장)
    확장 for문
24. 컬렉션
    객체만 저장, 꺼내올 때는 형변환
    List(순서 O, 중복 O), Set(중복 X 순서 X), Map(key - value)
25. 제너릭
    사용 목적 종류 T, ?
26. 상속
    재사용성, 개발시간 단축
    단일상속만 가능, 생성자 상속 불가, private 상속 불가
27. 객체 형 변환
28. 오버라이딩
    상위 클래스 메소드를 하위 클래스에서 재정의하는 것
29. 추상 클래스 abstract
    추상 메소드가 하나라도 있는 클래스
    일반 메소드도 작성 가능
    설계목적
    ↔ 인터페이스
    설계목적, 다중 구현 가능 추상 메소드, 정적 상수만 저장 가능
30. 스윙_배치 관리자
31. 1 ~ 2 줄 코딩하는 정도는 나올 수 있음
32. 입출력
    데이터, 영어 <= 스트림 vs 리더, 라이터 => 한글